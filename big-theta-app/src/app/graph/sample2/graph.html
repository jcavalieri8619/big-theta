<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Tree Example</title>
		<link rel="stylesheet" type="text/css" href="graph.css">

  </head>
  <body>
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<script src="testData.js"></script> 
	<script>

		var width = 960,
			height = 500,
			root;

		var force = d3.layout.force()
			.gravity(.05)
			.charge(-240)
			.linkDistance(60)
			.size([width, height])
			.on("tick", tick);

		var svg = d3.select("body").append("svg")
			.attr("width", width)
			.attr("height", height)
			.attr("class", "body");

		var link = svg.selectAll(".link"),
			node = svg.selectAll(".node");
			
		//d3.json("readme.json", function(error, json) {
		//	  if (error) throw error;

		//	  root = json;
		//	  update();
		//});
	
		root = treeData[0];
		update();
		
		function update() {
			console.log(root.id);
			var nodes = parseData(root),
			links = d3.layout.tree().links(nodes);
			
			// Restart the force layout.
			  force
				  .nodes(nodes)
				  .links(links)
				  .start();

			  // Update the links…
			  link = link.data(links, function(d) { return d.target.id; });

			  // Exit any old links.
			  link.exit().remove();

			  // Enter any new links.
			  link.enter().insert("line", ".node")
				  .attr("class", "link")
				  .attr("x1", function(d) { return d.source.x; })
				  .attr("y1", function(d) { return d.source.y; })
				  .attr("x2", function(d) { return d.target.x; })
				  .attr("y2", function(d) { return d.target.y; });

			  // Update the nodes…
			  node = node.data(nodes, function(d) { return d.id; }).style("fill", color);

			  // Exit any old nodes.
			  node.exit().remove();

			  // Enter any new nodes.
			  node.enter().append("circle")
				  .attr("class", "node")
				  .attr("cx", function(d) { return d.x; })
				  .attr("cy", function(d) { return d.y; })
				  .attr("r",10 )
				  .style("fill", color)
				  .text(function(d) { return d.name; })
				  .on("click", click)
				  .call(force.drag);
			
			node.append("title")
				.attr("text-anchor", "middle")
				.attr("class", "text")
				.text(function(d) { return d.name; });
				  
						
						
			
		}
		
		function tick() {
			  link.attr("x1", function(d) { return d.source.x; })
				  .attr("y1", function(d) { return d.source.y; })
				  .attr("x2", function(d) { return d.target.x; })
				  .attr("y2", function(d) { return d.target.y; });

			  node.attr("cx", function(d) { return d.x; })
				  .attr("cy", function(d) { return d.y; });
		}
		function parseData(root) {
			  var nodes = [], i = 0;
				console.log(nodes.id);
				
			  function recurse(node) {
				console.log(nodes.id);
				if (node.children){ 
					console.log(i)
					node.children.forEach(recurse);
				}
				if (!node.id) node.id = ++i;
				nodes.push(node);
			  }

			  recurse(root);
			  return nodes;
		}
		function color(d) {
			return d._children ? "#5182bd" : d.children ? "#51f91d" : "#fd8d3c";
		}
		// Toggle children on click.
		function click(d) {
		  if (!d3.event.defaultPrevented) {
			if (d.children) {
			  d._children = d.children;
			  d.children = null;
			} else {
			  d.children = d._children;
			  d._children = null;
				
			}
			update();
		  }
		}
	</script>
  
 </body>